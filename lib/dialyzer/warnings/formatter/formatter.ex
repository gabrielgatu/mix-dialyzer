defmodule Dialyzer.Formatter do
  import Dialyzer.Logger

  @doc """
  It gets a list of all the warnings generated by dialyzer and
  formats them into nice error messages, with ansi color support.
  """
  @spec format(list(), :short | :long) :: [String.t()]
  def format(warnings, type) do
    Enum.map(warnings, &format_warning(&1, type))
  end

  defp format_warning(warning, type) do
    {warning_name, arguments} = warning.message
    filepath = Path.relative_to_cwd(warning.file)
    line = warning.line
    tag = warning.tag

    try do
      warning = fetch_warning(warning_name)

      case type do
        :short ->
          header = "#{filepath}:#{line}"
          message = warning.format_short(arguments)

          "[#{color(:yellow, tag)}] #{color(:cyan, header)} - #{message}"

        :long ->
          header = generate_warning_header(warning.name, filepath, line, tag)

          message =
            arguments
            |> warning.format_long()
            |> String.split("\n")
            |> Enum.map(&("    " <> &1))
            |> Enum.join("\n")

          """
          #{color(:cyan, header)}

          #{message}
          """
      end
    rescue
      e ->
        error("Unknown error occurred: #{inspect(e)}")
    catch
      {:error, :unknown_warning, warning_name} ->
        error("Unknown warning: #{inspect(warning_name)}")

      {:error, :lexing, warning} ->
        error("Failed to lex warning: #{inspect(warning)}")

      {:error, :parsing, failing_string} ->
        error("Failed to parse warning: #{inspect(failing_string)}")

      {:error, :pretty_printing, failing_string} ->
        error("Failed to pretty print warning: #{inspect(failing_string)}")

      {:error, :formatting, code} ->
        error("Failed to format warning: #{inspect(code)}")
    end
  end

  @spec fetch_warning(atom) :: module
  defp fetch_warning(warning_name) do
    warnings = Dialyzer.Formatter.Warnings.warnings()

    if Map.has_key?(warnings, warning_name) do
      Map.get(warnings, warning_name)
    else
      throw({:error, :unknown_warning, warning_name})
    end
  end

  defp generate_warning_header(warning_name, filepath, line_nr, tag) do
    warning_fragment = " #{String.upcase(warning_name)} "
    filepath_fragment = " #{filepath}:#{line_nr}"
    tag_fragment = " [#{color(:yellow, tag)}] "

    len =
      80 -
        (String.length(warning_fragment) + String.length(filepath_fragment) +
           String.length(tag_fragment))

    separators = for _ <- 0..len, into: "", do: "-"

    String.slice(separators, 0..1)
    |> Kernel.<>(tag_fragment)
    |> Kernel.<>(warning_fragment)
    |> Kernel.<>(String.slice(separators, 2..-1))
    |> Kernel.<>(filepath_fragment)
  end
end
